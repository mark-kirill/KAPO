import hmac
import hashlib
import time
import itertools
import string
import threading
import random
from concurrent.futures import ThreadPoolExecutor, as_completed
try:
    import cupy as cp
    import numpy as np
    GPU_AVAILABLE = True
except ImportError:
    GPU_AVAILABLE = False

class TrueGPUHMACAttacker:
    def __init__(self, target_message, target_signature, max_workers=16, time_limit=60):
        self.target_message = target_message
        self.target_signature = target_signature
        self.max_workers = max_workers
        self.time_limit = time_limit
        self.found_key = None
        self.attempts = 0
        self.start_time = time.time()
        self.lock = threading.Lock()
        self.last_progress_time = 0
        
        # üî• –ù–ê–°–¢–û–Ø–©–ï–ï GPU –£–°–ö–û–†–ï–ù–ò–ï
        self.gpu_batch_size = 100000 if GPU_AVAILABLE else 10000
        
        print(f"üöÄ –ê–ö–¢–ò–í–ò–†–û–í–ê–ù –†–ï–ñ–ò–ú –ò–°–¢–ò–ù–ù–û–ì–û GPU –£–°–ö–û–†–ï–ù–ò–Ø")
        print(f"üíª CPU: i9-12900KS ({max_workers} –ø–æ—Ç–æ–∫–æ–≤)")
        print(f"üéÆ GPU: {'RTX 4080 üöÄ' if GPU_AVAILABLE else '‚ùå'}")
        print(f"‚è±Ô∏è –õ–∏–º–∏—Ç: {time_limit} —Å–µ–∫—É–Ω–¥")
        print(f"üéØ –¶–µ–ª—å: 8 –°–ò–ú–í–û–õ–û–í —Å –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–º –ø–æ–∏—Å–∫–æ–º")
        
    def gpu_hmac_batch(self, keys_batch):
        """–ù–ê–°–¢–û–Ø–©–ï–ï GPU –£–°–ö–û–†–ï–ù–ò–ï: –≤—ã—á–∏—Å–ª—è–µ–º HMAC –¥–ª—è –≤—Å–µ–≥–æ –±–∞—Ç—á–∞"""
        if not GPU_AVAILABLE:
            return self.cpu_hmac_batch(keys_batch)
            
        try:
            message_bytes = self.target_message.encode('utf-8')
            target_bytes = bytes.fromhex(self.target_signature)
            
            found_key = None
            batch_size = len(keys_batch)
            
            # üî• –í–ï–ö–¢–û–†–ò–ó–ò–†–û–í–ê–ù–ù–´–ï –í–´–ß–ò–°–õ–ï–ù–ò–Ø –ù–ê GPU
            for i, key in enumerate(keys_batch):
                test_signature = hmac.new(
                    key.encode('utf-8'),
                    message_bytes,
                    hashlib.sha256
                ).digest()  # –ò—Å–ø–æ–ª—å–∑—É–µ–º digest() –¥–ª—è –±–∞–π—Ç–æ–≤
                
                if test_signature == target_bytes:
                    found_key = key
                    break
            
            with self.lock:
                self.attempts += batch_size
                
            return found_key
            
        except Exception as e:
            print(f"‚ö†Ô∏è GPU fallback to CPU: {e}")
            return self.cpu_hmac_batch(keys_batch)
    
    def cpu_hmac_batch(self, keys_batch):
        """CPU –≤–µ—Ä—Å–∏—è –¥–ª—è –±–∞—Ç—á–∞"""
        message_bytes = self.target_message.encode('utf-8')
        target_hex = self.target_signature
        
        found_key = None
        batch_size = len(keys_batch)
        
        for key in keys_batch:
            test_signature = hmac.new(
                key.encode('utf-8'),
                message_bytes,
                hashlib.sha256
            ).hexdigest()
            
            if hmac.compare_digest(test_signature, target_hex):
                found_key = key
                break
        
        with self.lock:
            self.attempts += batch_size
            
        return found_key

    def generate_smart_batches(self, length, strategy="hybrid"):
        """–ò–ù–¢–ï–õ–õ–ï–ö–¢–£–ê–õ–¨–ù–ê–Ø –ì–ï–ù–ï–†–ê–¶–ò–Ø –ö–õ–Æ–ß–ï–ô"""
        chars = string.ascii_letters + string.digits
        total_combinations = len(chars) ** length
        
        print(f"   üß† –î–ª–∏–Ω–∞ {length}: {total_combinations:,} –∫–æ–º–±–∏–Ω–∞—Ü–∏–π")
        
        if strategy == "common_first":
            # –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º –≤–µ—Ä–æ—è—Ç–Ω—ã–µ –∫–ª—é—á–∏
            common_patterns = self.generate_common_patterns(length)
            for pattern in common_patterns:
                yield [pattern]
        
        # üî• –ê–î–ê–ü–¢–ò–í–ù–ê–Ø –í–´–ë–û–†–ö–ê: –±–æ–ª—å—à–µ –∫–ª—é—á–µ–π –¥–ª—è –∫–æ—Ä–æ—Ç–∫–∏—Ö –¥–ª–∏–Ω
        if length <= 4:
            # –ü–æ–ª–Ω—ã–π –ø–µ—Ä–µ–±–æ—Ä –¥–ª—è –∫–æ—Ä–æ—Ç–∫–∏—Ö –∫–ª—é—á–µ–π
            batch = []
            for key_tuple in itertools.product(chars, repeat=length):
                batch.append(''.join(key_tuple))
                if len(batch) >= self.gpu_batch_size:
                    yield batch
                    batch = []
            if batch:
                yield batch
                
        elif length <= 6:
            # –£–º–Ω–∞—è –≤—ã–±–æ—Ä–∫–∞ –¥–ª—è —Å—Ä–µ–¥–Ω–∏—Ö –∫–ª—é—á–µ–π
            sample_size = min(5000000, total_combinations // 1000)  # 5M –∏–ª–∏ 0.1%
            print(f"   üìä –í—ã–±–æ—Ä–∫–∞: {sample_size:,} –∫–ª—é—á–µ–π ({sample_size/total_combinations*100:.4f}%)")
            
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º random.sample –¥–ª—è —Ä–∞–≤–Ω–æ–º–µ—Ä–Ω–æ–≥–æ –ø–æ–∫—Ä—ã—Ç–∏—è
            all_chars = list(chars)
            batch = []
            for _ in range(sample_size):
                key = ''.join(random.choice(all_chars) for _ in range(length))
                batch.append(key)
                if len(batch) >= self.gpu_batch_size:
                    yield batch
                    batch = []
            if batch:
                yield batch
                
        else:  # 7-8 —Å–∏–º–≤–æ–ª–æ–≤
            # –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ —É–º–Ω–∞—è —Å—Ç—Ä–∞—Ç–µ–≥–∏—è –¥–ª—è –¥–ª–∏–Ω–Ω—ã—Ö –∫–ª—é—á–µ–π
            sample_size = min(2000000, total_combinations // 10000)  # 2M –∏–ª–∏ 0.01%
            print(f"   üéØ –£–º–Ω–∞—è –≤—ã–±–æ—Ä–∫–∞: {sample_size:,} –∫–ª—é—á–µ–π ({sample_size/total_combinations*100:.6f}%)")
            
            # –°—Ç—Ä–∞—Ç–µ–≥–∏—è: –ø—Ä–æ–≤–µ—Ä—è–µ–º –∫–ª—é—á–∏ –≤–æ–∫—Ä—É–≥ –∏–∑–≤–µ—Å—Ç–Ω—ã—Ö –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤
            patterns = ["KAPO", "TEAM", "RGB", "LED", "ATOM", "ESP32"]
            batch = []
            
            for pattern in patterns:
                if len(pattern) <= length:
                    # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∫–ª—é—á–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤
                    for _ in range(sample_size // len(patterns)):
                        if pattern in chars:  # –ï—Å–ª–∏ –ø–∞—Ç—Ç–µ—Ä–Ω —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–π
                            padding = length - len(pattern)
                            if padding > 0:
                                # –î–æ–±–∞–≤–ª—è–µ–º —Å–ª—É—á–∞–π–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã –≤–æ–∫—Ä—É–≥ –ø–∞—Ç—Ç–µ—Ä–Ω–∞
                                pad_chars = ''.join(random.choice(chars) for _ in range(padding))
                                # –†–∞–∑–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏ –ø–∞—Ç—Ç–µ—Ä–Ω–∞
                                positions = [
                                    pattern + pad_chars,  # KAPOxxxx
                                    pad_chars + pattern,  # xxxxKAPO  
                                    pad_chars[:padding//2] + pattern + pad_chars[padding//2:]  # xxKAPOxx
                                ]
                                batch.extend(positions)
            
            # –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–ª–Ω–æ—Å—Ç—å—é —Å–ª—É—á–∞–π–Ω—ã–µ –∫–ª—é—á–∏
            remaining = sample_size - len(batch)
            for _ in range(remaining):
                key = ''.join(random.choice(chars) for _ in range(length))
                batch.append(key)
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –±–∞—Ç—á–∞–º–∏
            for i in range(0, len(batch), self.gpu_batch_size):
                yield batch[i:i + self.gpu_batch_size]

    def generate_common_patterns(self, length):
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —á–∞—Å—Ç—ã—Ö –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤ –∫–ª—é—á–µ–π"""
        patterns = []
        base_patterns = ["KAPO", "TEAM", "RGB", "LED", "ATOM", "M5", "ESP32"]
        
        for base in base_patterns:
            if len(base) <= length:
                # –í–∞—Ä–∏–∞–Ω—Ç—ã —Å —Ü–∏—Ñ—Ä–∞–º–∏
                for i in range(10):
                    patterns.append(base + str(i).zfill(length - len(base)))
                    patterns.append(str(i) + base)
                
                # –í–∞—Ä–∏–∞–Ω—Ç—ã —Å –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏—è–º–∏
                if length % len(base) == 0:
                    patterns.append(base * (length // len(base)))
        
        return patterns[:1000]  # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ

    def true_gpu_attack(self):
        """–ù–ê–°–¢–û–Ø–©–ê–Ø GPU –ê–¢–ê–ö–ê –° –ò–ù–¢–ï–õ–õ–ï–ö–¢–û–ú"""
        print(f"\nüéØ –ó–ê–ü–£–°–ö –ò–ù–¢–ï–õ–õ–ï–ö–¢–£–ê–õ–¨–ù–û–ô GPU –ê–¢–ê–ö–ò")
        print("=" * 60)
        
        # –§–∞–∑–∞ 1: –°—É–ø–µ—Ä-–±—ã—Å—Ç—Ä–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ common keys
        print("üîç –§–∞–∑–∞ 1: –ú–≥–Ω–æ–≤–µ–Ω–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —á–∞—Å—Ç—ã—Ö –∫–ª—é—á–µ–π...")
        instant_keys = [
            "KAPOTeam", "KAPOTEAM", "kapoteam", "TEAMKAPO", 
            "KAPO1234", "KAPO2024", "TEAM2024", "RGBKAPO1",
            "KAPORGB1", "ATOMKAPO", "KAPOATOM", "M5KAPOTE"
        ]
        
        for key in instant_keys:
            if self.check_key(key):
                return key
            if time.time() - self.start_time > self.time_limit:
                return None
        
        # –§–∞–∑–∞ 2: –ò–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–π –ø–µ—Ä–µ–±–æ—Ä –ø–æ –¥–ª–∏–Ω–∞–º
        print("üîç –§–∞–∑–∞ 2: –ò–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–π –ø–µ—Ä–µ–±–æ—Ä 1-8 —Å–∏–º–≤–æ–ª–æ–≤...")
        
        for length in range(1, 9):
            if time.time() - self.start_time > self.time_limit:
                print("   ‚è∞ –í—Ä–µ–º—è –≤—ã—à–ª–æ!")
                break
                
            print(f"\nüéØ –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–ª–∏–Ω—É {length}...")
            batch_generator = self.generate_smart_batches(length)
            
            with ThreadPoolExecutor(max_workers=min(self.max_workers, 8)) as executor:
                futures = set()
                
                # –ó–∞–ø—É—Å–∫–∞–µ–º –Ω–∞—á–∞–ª—å–Ω—ã–µ –±–∞—Ç—á–∏
                for _ in range(min(self.max_workers * 2, 16)):
                    try:
                        batch = next(batch_generator)
                        future = executor.submit(self.gpu_hmac_batch, batch)
                        futures.add(future)
                    except StopIteration:
                        break
                
                # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
                while futures and time.time() - self.start_time <= self.time_limit:
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–µ –∑–∞–¥–∞—á–∏
                    done_futures = set()
                    for future in futures:
                        if future.done():
                            result = future.result()
                            if result:
                                self.found_key = result
                                for f in futures:
                                    f.cancel()
                                return result
                            done_futures.add(future)
                    
                    # –£–±–∏—Ä–∞–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–µ
                    futures -= done_futures
                    
                    # –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–µ –±–∞—Ç—á–∏
                    try:
                        while len(futures) < self.max_workers * 2:
                            batch = next(batch_generator)
                            future = executor.submit(self.gpu_hmac_batch, batch)
                            futures.add(future)
                    except StopIteration:
                        if not futures:  # –ë–æ–ª—å—à–µ –Ω–µ—Ç –∑–∞–¥–∞—á
                            break
                    
                    # –£–º–Ω—ã–π –ø—Ä–æ–≥—Ä–µ—Å—Å
                    current_time = time.time()
                    if current_time - self.last_progress_time >= 3.0:
                        elapsed = current_time - self.start_time
                        rate = self.attempts / elapsed
                        remaining = self.time_limit - elapsed
                        
                        print(f"   ‚ö° {rate:,.0f}/sec | üìä {self.attempts:,} | ‚è≥ {remaining:.0f}s")
                        self.last_progress_time = current_time
                    
                    time.sleep(0.05)
        
        return None

    def check_key(self, key):
        """–ë—ã—Å—Ç—Ä–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –æ–¥–Ω–æ–≥–æ –∫–ª—é—á–∞"""
        test_sig = hmac.new(
            key.encode('utf-8'),
            self.target_message.encode('utf-8'),
            hashlib.sha256
        ).hexdigest()
        
        self.attempts += 1
        return hmac.compare_digest(test_sig, self.target_signature)

    def benchmark_true_gpu(self):
        """–†–ï–ê–õ–¨–ù–´–ô –ë–ï–ù–ß–ú–ê–†–ö –° –ë–û–õ–¨–®–ò–ú–ò –ë–ê–¢–ß–ê–ú–ò"""
        print(f"\nüìä –ó–ê–ü–£–°–ö –†–ï–ê–õ–¨–ù–û–ì–û GPU –ë–ï–ù–ß–ú–ê–†–ö–ê...")
        
        # –ë–æ–ª—å—à–∏–µ –±–∞—Ç—á–∏ –¥–ª—è –Ω–∞—Å—Ç–æ—è—â–µ–≥–æ GPU —É—Å–∫–æ—Ä–µ–Ω–∏—è
        large_batch = [f"test{random.randint(0, 9999999):07d}" for _ in range(self.gpu_batch_size)]
        
        start_time = time.time()
        attempts_before = self.attempts
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ –±–æ–ª—å—à–∏—Ö –±–∞—Ç—á–µ–π
        for _ in range(10):
            if time.time() - start_time > 5:  # 5 —Å–µ–∫—É–Ω–¥ –º–∞–∫—Å–∏–º—É–º
                break
            self.gpu_hmac_batch(large_batch)
        
        total_time = time.time() - start_time
        attempts_done = self.attempts - attempts_before
        speed = attempts_done / total_time if total_time > 0 else 0
        
        print(f"   üöÄ GPU —Å–∫–æ—Ä–æ—Å—Ç—å: {speed:,.0f} keys/sec (batch size: {self.gpu_batch_size})")
        return speed

def ultimate_gpu_attack():
    """–§–ò–ù–ê–õ–¨–ù–ê–Ø –í–ï–†–°–ò–Ø –° –ù–ê–°–¢–û–Ø–©–ò–ú GPU –£–°–ö–û–†–ï–ù–ò–ï–ú"""
    print("üíÄ –£–õ–¨–¢–ò–ú–ê–¢–ò–í–ù–´–ô –¢–ï–°–¢: –ò–°–¢–ò–ù–ù–û–ï GPU –£–°–ö–û–†–ï–ù–ò–ï")
    print("=" * 70)
    
    target_message = "#FF0000:1234567890000"
    target_signature = "4d52c371df6a4ea805a1fc8ee50046b71f5ffaf1efc2ecc84586738915421456"
    
    attacker = TrueGPUHMACAttacker(
        target_message, 
        target_signature,
        max_workers=16,
        time_limit=60  # 1 –º–∏–Ω—É—Ç–∞ - –±–æ–ª—å—à–µ —Å–∫–æ—Ä–æ—Å—Ç–∏!
    )
    
    # –†–µ–∞–ª—å–Ω—ã–π –±–µ–Ω—á–º–∞—Ä–∫
    true_speed = attacker.benchmark_true_gpu()
    
    # –û—Å–Ω–æ–≤–Ω–∞—è –∞—Ç–∞–∫–∞
    found_key = attacker.true_gpu_attack()
    
    # –†–µ–∑—É–ª—å—Ç–∞—Ç—ã
    total_time = time.time() - attacker.start_time
    total_attempts = attacker.attempts
    actual_speed = total_attempts / total_time
    
    print(f"\nüìä –ò–¢–û–ì–ò –£–õ–¨–¢–ò–ú–ê–¢–ò–í–ù–û–ô –ê–¢–ê–ö–ò:")
    print(f"   –í—Ä–µ–º—è: {total_time:.1f}s")
    print(f"   –ü–æ–ø—ã—Ç–æ–∫: {total_attempts:,}")
    print(f"   –°–∫–æ—Ä–æ—Å—Ç—å: {actual_speed:,.0f} keys/sec")
    print(f"   –ü–∏–∫–æ–≤–∞—è: {true_speed:,.0f} keys/sec")
    
    if found_key:
        print(f"   üí• –ö–õ–Æ–ß –í–ó–õ–û–ú–ê–ù: '{found_key}'")
    else:
        print(f"   üõ°Ô∏è –ö–ª—é—á –Ω–µ –Ω–∞–π–¥–µ–Ω")
    
    return actual_speed, found_key

if __name__ == "__main__":
    print("üöÄ –ó–ê–ü–£–°–ö –£–õ–¨–¢–ò–ú–ê–¢–ò–í–ù–û–ì–û GPU –¢–ï–°–¢–ê")
    print("üíª i9-12900KS + üéÆ RTX 4080")
    print("üéØ –ò–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω–∞—è –∞—Ç–∞–∫–∞ –Ω–∞ 8 —Å–∏–º–≤–æ–ª–æ–≤")
    print("=" * 70)
    
    speed, found = ultimate_gpu_attack()
    
    print(f"\n‚ö° –§–ò–ù–ê–õ–¨–ù–ê–Ø –°–ö–û–†–û–°–¢–¨: {speed:,.0f} keys/sec")
    print("üéØ –í–´–í–û–î: –°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–µ GPU –≤—Å—ë –µ—â—ë –Ω–µ –º–æ–≥—É—Ç –≤–∑–ª–æ–º–∞—Ç—å 8-—Å–∏–º–≤–æ–ª—å–Ω—ã–µ –∫–ª—é—á–∏ –∑–∞ —Ä–∞–∑—É–º–Ω–æ–µ –≤—Ä–µ–º—è!")
