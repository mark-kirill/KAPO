# common.py
BASE_URL = "http://192.168.4.1"

def encode_color(color_hex: str) -> str:
    return color_hex.replace("#", "%23")

# test_overload_stability.py
import requests
import time
import random
from common import BASE_URL, encode_color

def random_color():
    return "#{:02X}{:02X}{:02X}".format(
        random.randint(0, 255),
        random.randint(0, 255),
        random.randint(0, 255)
    )

def send_set_command():
    color = random_color()
    url = f"{BASE_URL}/set?value={encode_color(color)}"
    try:
        start = time.time()
        resp = requests.get(url, timeout=1)
        latency = time.time() - start
        return latency, resp.status_code
    except requests.exceptions.RequestException:
        return None, None

def test_overload():
    print("=== –¢–µ—Å—Ç –Ω–∞ –ø–µ—Ä–µ–≥—Ä—É–∑–∫—É ESP32 ===")
    rates = [10, 20, 50, 75, 100, 150]  # –∫–æ–º–∞–Ω–¥ –≤ —Å–µ–∫—É–Ω–¥—É
    stop = False

    for rate in rates:
        interval = 1.0 / rate
        print(f"\nüì∂ –û—Ç–ø—Ä–∞–≤–ª—è–µ–º {rate} –∫–æ–º–∞–Ω–¥/—Å–µ–∫")

        latencies = []
        timeouts = 0

        start_time = time.time()
        while time.time() - start_time < 5:
            latency, status = send_set_command()
            if latency is not None:
                latencies.append(latency)
            else:
                timeouts += 1
            time.sleep(interval)

        if not latencies:
            print("‚ùå ESP32 –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç –≤–æ–æ–±—â–µ.")
            break

        avg_latency = sum(latencies) / len(latencies)
        max_latency = max(latencies)

        print(f"–°—Ä–µ–¥–Ω—è—è –∑–∞–¥–µ—Ä–∂–∫–∞: {avg_latency:.3f} —Å–µ–∫")
        print(f"–ú–∞–∫—Å. –∑–∞–¥–µ—Ä–∂–∫–∞: {max_latency:.3f} —Å–µ–∫")
        print(f"–ü–æ—Ç–µ—Ä—å: {timeouts}")

        if avg_latency > 0.5 or timeouts > 0:
            print("‚ùó –û–±–Ω–∞—Ä—É–∂–µ–Ω—ã –ø—Ä–∏–∑–Ω–∞–∫–∏ –ø–µ—Ä–µ–≥—Ä—É–∑–∫–∏.")
            stop = True
            break

    print("\n‚è≥ –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è...")
    time.sleep(3)

    try:
        resp = requests.get(f"{BASE_URL}/get", timeout=2)
        if resp.status_code == 200:
            print("‚úÖ –£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏–ª–æ—Å—å.")
        else:
            print("‚ùå –£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ –Ω–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏–ª–æ—Å—å.")
    except:
        print("‚ùå –ù–µ—Ç –æ—Ç–≤–µ—Ç–∞ –æ—Ç ESP32.")

if __name__ == "__main__":
    test_overload()


# test_visual_smoothness.py
import time
import requests
from common import BASE_URL, encode_color

FREQUENCIES_HZ = [1, 2, 5, 10, 20, 50]
DURATION = 5  # —Å–µ–∫—É–Ω–¥ –Ω–∞ –∫–∞–∂–¥—ã–π —Ç–µ—Å—Ç

COLORS = ["#FF0000", "#00FF00", "#0000FF"]  # –∫—Ä–∞—Å–Ω—ã–π, –∑–µ–ª—ë–Ω—ã–π, —Å–∏–Ω–∏–π

def cycle_colors(freq_hz):
    delay = 1.0 / freq_hz
    print(f"\n–¢–µ—Å—Ç —á–∞—Å—Ç–æ—Ç—ã: {freq_hz} –ì—Ü (–∑–∞–¥–µ—Ä–∂–∫–∞ {delay:.3f} —Å–µ–∫)")

    start_time = time.time()
    i = 0
    while time.time() - start_time < DURATION:
        color = COLORS[i % len(COLORS)]
        requests.get(f"{BASE_URL}/set?value={encode_color(color)}", timeout=1)
        time.sleep(delay)
        i += 1

def main():
    print("=== –í–∏–∑—É–∞–ª—å–Ω—ã–π —Ç–µ—Å—Ç –ø–ª–∞–≤–Ω–æ—Å—Ç–∏ —Å–º–µ–Ω—ã —Ü–≤–µ—Ç–∞ LED ===\n")
    print("–°–º–æ—Ç—Ä–∏ –Ω–∞ M5 Atom. –û—Ç–≤–µ—Ç—å –ø–æ—Å–ª–µ –∫–∞–∂–¥–æ–≥–æ —Ç–µ—Å—Ç–∞.\n")

    for freq in FREQUENCIES_HZ:
        cycle_colors(freq)
        answer = input("–°–º–µ–Ω–∞ —Ü–≤–µ—Ç–∞ –±—ã–ª–∞ –ø–ª–∞–≤–Ω–æ–π –∏ —Ä–∞–∑–ª–∏—á–∏–º–æ–π? (–¥–∞/–Ω–µ—Ç): ").strip().lower()
        if answer == "–Ω–µ—Ç":
            print(f"\n‚ùó –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –¥–æ–ø—É—Å—Ç–∏–º–∞—è —á–∞—Å—Ç–æ—Ç–∞: {freq} –ì—Ü")
            break
    else:
        print("\n‚úÖ –í—Å–µ —á–∞—Å—Ç–æ—Ç—ã –¥–æ 50 –ì—Ü –ø—Ä–æ—à–ª–∏ —É—Å–ø–µ—à–Ω–æ.")

if __name__ == "__main__":
    main()


